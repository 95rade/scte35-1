/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.turner.decoder;

import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;



/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//com.turner.decoder//decoder//EN",
        autostore = false)
@TopComponent.Description(
        preferredID = "decoderTopComponent",
        //iconBase="SET/PATH/TO/ICON/HERE", 
        persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "output", openAtStartup = true)
@ActionID(category = "Window", id = "com.turner.decoder.decoderTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_decoderAction",
        preferredID = "decoderTopComponent")
@Messages({
    "CTL_decoderAction=decoder",
    "CTL_decoderTopComponent=decoder Window",
    "HINT_decoderTopComponent=This is a decoder window"
})
public final class decoderTopComponent extends TopComponent {

    public static final int SPLICE_NULL = 0x00;
    public static final int SPLICE_SCHEDULE = 0x04;
    public static final int SPLICE_INSERT = 0x05;
    public static final int TIME_SIGNAL = 0x06;
    public static final int BANDWIDTH_RESERVATION = 0x07;
    public static final int PRIVATE_COMMAND = 0x00ff;
    
    public static byte[] b64;
    
    public static class spliceInfoSection {
        public static int tableID;
        public static int sectionSyntaxIndicator;
        public static int privateIndicator;
        public static int reserved1;
        public static int sectionLength;
        public static int protocolVersion;
        public static int encryptedPacket;
        public static int encryptionAlgorithm;
        public static long ptsAdjustment;
        public static int cwIndex;
        public static int tier;
        public static int spliceCommandLength;
        public static int spliceCommandType;
        public static int descriptorLoopLength;
        public static int alignmentStuffing;
        public static int eCRC32;
        public static int CRC32;
    }
    
    public static class spliceTime {
        public int timeSpecifiedFlag;
        public int reserved1;
        public long ptsTime;
        public int reserved2;
    }
    
    public class breakDuration {
        int autoReturn;
        int reserved1;
        long duration;
    }
    
    public static class spliceInsert {
        public static int spliceEventID;
        public static int spliceEventCancelIndicator;
        public static int reserved1;
        public static int outOfNetworkIndicator;
        public static int programSpliceFlag;
        public static spliceTime sisp = new spliceTime();
        public static int durationFlag;
        public static int spliceImmediateFlag;
        public static breakDuration brdr;
        public static int reserved2;
        public static int uniqueProgramID;
        public static int availNum;
        public static int availsExpected;
    }
    
    public static class timeSignal {
        public static spliceTime tssp = new spliceTime();
    }
    
    public class availDescriptor {
        int spliceDescriptorTag;
        int descriptorLength;
        int identifier;
        int providerAvailID;
    }
    
    public class DTMFDescriptor {
        int spliceDescriptorTag;
        int descriptorLength;
        int identifier;
        int preroll;
        int dtmfCount;
        int reserved;
        byte[] DTMFChar = new byte[8];
    }
    
    public class segmentationDescriptor {
        int spliceDescriptorTag;
        int descriptorLength;
        int identifier;
        int segmentationEventID;
        int segmentationEventCancelIndicator;
        int reserved1;
        int programSegmentationFlag;
        int segmentationDurationFlag;
        int deliveryNotRestricted;
        int webDeliveryAllowedFlag;
        int noRegionalBlackoutFlag;
        int archiveAllowed;
        int deviceRestriction;
        int reserved2;
        long segmentationDuration;
        int segmentationUPIDtype;
        int segmentationUPIDlength;
        int segmentationTypeID;
        int segmentNum;
        int segmentsExpected;
    }
    
    
    public decoderTopComponent() {
        initComponents();
        setName(Bundle.CTL_decoderTopComponent());
        setToolTipText(Bundle.HINT_decoderTopComponent());

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        base64in = new javax.swing.JTextField();
        convert64 = new javax.swing.JToggleButton();
        ConvertHex = new javax.swing.JToggleButton();
        hexin = new javax.swing.JTextField();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        outText = new javax.swing.JTextPane();

        base64in.setText(org.openide.util.NbBundle.getMessage(decoderTopComponent.class, "decoderTopComponent.base64in.text")); // NOI18N
        base64in.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                base64inActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(convert64, org.openide.util.NbBundle.getMessage(decoderTopComponent.class, "decoderTopComponent.convert64.text")); // NOI18N
        convert64.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                convert64ActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(ConvertHex, org.openide.util.NbBundle.getMessage(decoderTopComponent.class, "decoderTopComponent.ConvertHex.text")); // NOI18N

        hexin.setText(org.openide.util.NbBundle.getMessage(decoderTopComponent.class, "decoderTopComponent.hexin.text")); // NOI18N

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(convert64)
                    .addComponent(ConvertHex))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(base64in, javax.swing.GroupLayout.DEFAULT_SIZE, 522, Short.MAX_VALUE)
                    .addComponent(hexin))
                .addContainerGap(18, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(base64in, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(convert64))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ConvertHex)
                    .addComponent(hexin, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jScrollPane1.setViewportView(outText);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 428, Short.MAX_VALUE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void base64inActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_base64inActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_base64inActionPerformed

    
    private void convert64ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_convert64ActionPerformed
        b64 = Base64.decodeFast(base64in.getText());
        int i1;
        int i2;
        long l1;
        long l2;
        long l3;
        long l4;
        long l5;
        int bufptr = 0;
        int desptr = 0;
        
        String stemp = "";
        String ot = "";

        ot += "Decoded length = " + b64.length + "\n";
        
        for (int i=0;i<b64.length;i++) {
            stemp += String.format("%02X", b64[i]);
        }
        hexin.setText(stemp);
                      
        spliceInfoSection.tableID = b64[0] & 0x00ff;
        if (spliceInfoSection.tableID != 0x0FC) {
            ot = "Invalid Table ID != 0xFC";
            outText.setText(ot);
            return;            
        }
        ot += "Table ID = 0xFC\n";
        
        spliceInfoSection.sectionSyntaxIndicator = (b64[1] >> 7) & 0x01;
        if (spliceInfoSection.sectionSyntaxIndicator != 0) {
            ot += "ERROR Long section used\n";
        } else {
            ot += "MPEG Short Section\n";
        }
        
        spliceInfoSection.privateIndicator = (b64[1] >> 6) & 0x01;
        if (spliceInfoSection.privateIndicator != 0) {
            ot += "ERROR Private section signaled\n";
        } else {
            ot += "Not Private\n";
        }
        
        spliceInfoSection.reserved1 = (b64[1] >> 4) & 0x03;
        ot += String.format("Reserved = 0x%x\n", spliceInfoSection.reserved1);
        
        i1 = b64[1] & 0x0f;
        i2 = b64[2] & 0x00ff;
        spliceInfoSection.sectionLength = (i1 << 8) + i2;
        ot += ("Section Length = " + spliceInfoSection.sectionLength + "\n");
        
        spliceInfoSection.protocolVersion = b64[3];
        ot += ("Protocol Version = " + spliceInfoSection.protocolVersion + "\n");

        spliceInfoSection.encryptedPacket = (b64[4] >> 7) & 0x01;
        spliceInfoSection.encryptionAlgorithm = (b64[4] >> 1) & 0x3F;
        if (spliceInfoSection.encryptedPacket != 0) {
            ot += "Encrypted Packet\n";
            ot += String.format("Encryption Algorithm = 0x%x\n", spliceInfoSection.encryptionAlgorithm);
        } else {
            ot += "unencrypted Packet\n";            
        }
        
        l1 = b64[4] & 0x01;
        l2 = b64[5] & 0x00ff;
        l3 = b64[6] & 0x00ff;
        l4 = b64[7] & 0x00ff;
        l5 = b64[8] & 0x00ff;
        spliceInfoSection.ptsAdjustment = (l1<<32) + (l2<<24) + (l3<<16) + (l4 << 8) + l5;
        ot += String.format("PTS Adjustment = 0x%09x\n", spliceInfoSection.ptsAdjustment);
        
        spliceInfoSection.cwIndex = b64[9] & 0x00ff;
        if (spliceInfoSection.encryptedPacket != 0) {
            ot += String.format("CW Index = 0x%x\n", spliceInfoSection.cwIndex);
        }        
        
        i1 = b64[10] & 0x00ff;
        i2 = (b64[11] & 0x00f0) >> 4;
        spliceInfoSection.tier = (i1 << 4) + i2;
        ot += String.format("Tier = 0x%x\n", spliceInfoSection.tier);       
        
        i1 = b64[11] & 0x000f;
        i2 = b64[12] & 0x00ff;
        spliceInfoSection.spliceCommandLength = (i1 << 8) + i2;
        ot += String.format("Splice Command Length = 0x%x\n", spliceInfoSection.spliceCommandLength);       
        
        spliceInfoSection.spliceCommandType = b64[13] & 0x00ff;
        bufptr = 14;
        switch (spliceInfoSection.spliceCommandType) {
            case SPLICE_NULL :
                ot += "Splice Null\n";
                break;
            case SPLICE_SCHEDULE:
                ot += "Splice Schedule\n";
                break;
            case SPLICE_INSERT:
                ot += "Splice Insert\n";
                l1 = b64[bufptr] & 0x00ff;
                bufptr++;
                l2 = b64[bufptr] & 0x00ff;
                bufptr++;
                l3 = b64[bufptr] & 0x00ff;
                bufptr++;
                l4 = b64[bufptr] & 0x00ff;
                bufptr++;
                spliceInsert.spliceEventID = (int) (((l1 << 24) + (l2 << 16) + (l3 << 8) + l4) & 0x00ffffffff);
                ot += String.format("Splice Event ID = 0x%x\n", spliceInsert.spliceEventID);
                
                i1 = b64[bufptr] & 0x080;
                bufptr++;
                if (i1 != 0) {
                    spliceInsert.spliceEventCancelIndicator = 1;
                    ot += "Splice Event Canceled\n";
                } else {
                    spliceInsert.spliceEventCancelIndicator = 0;
                }
                
                spliceInsert.outOfNetworkIndicator = (b64[bufptr] & 0x080) >> 7;
                spliceInsert.programSpliceFlag = (b64[bufptr] & 0x040) >> 6;
                spliceInsert.durationFlag = (b64[bufptr] & 0x020) >> 5;
                spliceInsert.spliceImmediateFlag = (b64[bufptr] & 0x010) >> 4;

                ot += "Flags OON=" + spliceInsert.outOfNetworkIndicator + " Prog=" + spliceInsert.programSpliceFlag
                        + " Duration=" + spliceInsert.durationFlag + " Immediate=" + spliceInsert.spliceImmediateFlag + "\n";

                if ((spliceInsert.programSpliceFlag != 0) && (spliceInsert.spliceImmediateFlag != 0)) {
                    if ((b64[bufptr] & 0x080) != 0) {
                        // time specified
                        l1 = b64[bufptr] & 0x01;
                        bufptr++;
                        l2 = b64[bufptr] & 0x00ff;
                        bufptr++;
                        l3 = b64[bufptr] & 0x00ff;
                        bufptr++;
                        l4 = b64[bufptr] & 0x00ff;
                        bufptr++;
                        l5 = b64[bufptr] & 0x00ff;
                        spliceInsert.sisp.ptsTime = (l1 << 32) + (l2 << 24) + (l3 << 16) + (l4 << 8) + l5;
                        ot += String.format("Splice time = 0x%09x\n", spliceInsert.sisp.ptsTime);
                    }
                    bufptr++;
                }

                if (spliceInsert.durationFlag != 0) {
                    spliceInsert.brdr.autoReturn = (b64[bufptr] & 0x080) >> 7;
                    if (spliceInsert.brdr.autoReturn != 0) {
                        ot += "Auto Return\n";
                    } 
                    l1 = b64[bufptr] & 0x01;
                    bufptr++;
                    l2 = b64[bufptr] & 0x00ff;
                    bufptr++;
                    l3 = b64[bufptr] & 0x00ff;
                    bufptr++;
                    l4 = b64[bufptr] & 0x00ff;
                    bufptr++;
                    l5 = b64[bufptr] & 0x00ff;
                    bufptr++;
                    spliceInsert.brdr.duration = (l1 << 32) + (l2 << 24) + (l3 << 16) + (l4 << 8) + l5;
                    ot += String.format("break duration = 0x%09x\n", spliceInsert.brdr.duration);
                }
                i1 = b64[bufptr] & 0x00ff;
                bufptr++;
                i2 = b64[bufptr] & 0x00ff;
                bufptr++;
                spliceInsert.uniqueProgramID = (i1 << 8) + i2;
                ot += "Unique Program ID = " + spliceInsert.uniqueProgramID + "\n";
                
                spliceInsert.availNum = b64[bufptr] & 0x00ff;
                bufptr++;
                ot += "Avail Num = " + spliceInsert.availNum + "\n";

                spliceInsert.availsExpected = b64[bufptr] & 0x00ff;
                bufptr++;
                ot += "Avails Expected = " + spliceInsert.availsExpected + "\n";

                break;
            case TIME_SIGNAL:
                ot += "Time Signal\n";
                timeSignal.tssp.timeSpecifiedFlag = (b64[bufptr] & 0x080) >> 7;
                if (timeSignal.tssp.timeSpecifiedFlag != 0) {
                    // time specified
                    l1 = b64[bufptr] & 0x01;
                    bufptr++;
                    l2 = b64[bufptr] & 0x00ff;
                    bufptr++;
                    l3 = b64[bufptr] & 0x00ff;
                    bufptr++;
                    l4 = b64[bufptr] & 0x00ff;
                    bufptr++;
                    l5 = b64[bufptr] & 0x00ff;
                    timeSignal.tssp.ptsTime = (l1 << 32) + (l2 << 24) + (l3 << 16) + (l4 << 8) + l5;
                    ot += String.format("Time = 0x%09x\n", timeSignal.tssp.ptsTime);
                }
                bufptr++;
                break;
            case BANDWIDTH_RESERVATION:
                ot += "Bandwidth Reservation\n";
                break;
            case PRIVATE_COMMAND :
                ot += "Private Command\n";
                break;
            default :
                ot += String.format("ERROR Unknown command = 0x%x\n", spliceInfoSection.spliceCommandType);
                // Unknown command, oops
                break;
        }
        
        if (spliceInfoSection.spliceCommandLength != 0x0fff) { // legacy check
            if (bufptr != (spliceInfoSection.spliceCommandLength + 14)) {
                ot += "ERROR decoded command length " + bufptr + " not equal to specified command length " + spliceInfoSection.spliceCommandLength + "\n";
                //Some kind of error, or unknown command
                //bufptr = spliceInfoSection.spliceCommandLength + 14;
            }
        }

        
        i1 = b64[bufptr] & 0x00ff;
        bufptr++;
        i2 = b64[bufptr] & 0x00ff;
        bufptr++;
        spliceInfoSection.descriptorLoopLength = (i1 << 8) + i2;
        ot += "Descriptor Loop Length = " + spliceInfoSection.descriptorLoopLength + "\n";
        
        desptr = bufptr;
  
        if (spliceInfoSection.descriptorLoopLength > 0) {
            int tag = b64[bufptr] & 0x00ff;
            bufptr++;
            int len = b64[bufptr] & 0x00ff;
            bufptr++;
            l1 = b64[bufptr] & 0x00ff;
            bufptr++;
            l2 = b64[bufptr] & 0x00ff;
            bufptr++;
            l3 = b64[bufptr] & 0x00ff;
            bufptr++;
            l4 = b64[bufptr] & 0x00ff;
            bufptr++;
            int identifier = (int) (((l1 << 24) + (l2 << 16) + (l3 << 8) + l4) & 0x00ffffffff);
            if (identifier == 0x43554549) {
                switch (tag) {
                    case 0:
                        ot += "Avail Descriptor -\n";
                        break;
                    case 1:
                        ot += "DTMF Descriptor -\n";
                        break;
                    case 2:
                        ot += "Segmentation Descriptor -\n";
                        break;
                }
            } else {
                ot += String.format("Private Descriptor tag=%d Length=%didentifier = %0x08x\n", tag, len, identifier);
                bufptr += len - 4;
            }



        }
        
        if (bufptr != (spliceInfoSection.descriptorLoopLength + desptr)) {
                ot += "ERROR decoded descriptor length " + bufptr + " not equal to specified command length " + spliceInfoSection.spliceCommandLength + "\n";            
                bufptr = desptr + spliceInfoSection.descriptorLoopLength;
        }
        
        if (spliceInfoSection.encryptedPacket != 0) {
        spliceInfoSection.alignmentStuffing = 0;
        spliceInfoSection.eCRC32 = 0;
        }
        
        l1 = b64[bufptr] & 0x00ff;
        bufptr++;
        l2 = b64[bufptr] & 0x00ff;
        bufptr++;
        l3 = b64[bufptr] & 0x00ff;
        bufptr++;
        l4 = b64[bufptr] & 0x00ff;
        bufptr++;
        spliceInfoSection.CRC32 = (int)(((l1<<24) + (l2<<16) + (l3<<8) + l4) & 0x00ffffffff);
        ot += String.format("CRC32 = 0x%08x\n", spliceInfoSection.CRC32);
 
        outText.setText(ot);
        
        
    }//GEN-LAST:event_convert64ActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JToggleButton ConvertHex;
    private javax.swing.JTextField base64in;
    private javax.swing.JToggleButton convert64;
    private javax.swing.JTextField hexin;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextPane outText;
    // End of variables declaration//GEN-END:variables
    @Override
    public void componentOpened() {
        // TODO add custom code on component opening
    }

    @Override
    public void componentClosed() {
        // TODO add custom code on component closing
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }
}
